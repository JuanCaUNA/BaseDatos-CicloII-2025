/*
Calculo de tamaño al convertir de texto a RAW
Tamaño en bytes = LONGITUD_EN_CARACTERES * 2
varchar2(100) -> 200 bytes -> puede almacenar hasta 100 caracteres
caracteres especiales pueden requerir más espacio nx4 100->400 bytes
*/

-- * TABLA *
CREATE TABLE ACS_CLAVE (
    ACL_ID       NUMBER GENERATED BY DEFAULT AS IDENTITY,
    ACL_NOMBRE_CLAVE VARCHAR2(50) UNIQUE NOT NULL,
    ACL_TIPO     VARCHAR2(20) NOT NULL, -- Correo SMTP, OTRO
    ACL_CLAVE    RAW(400) NOT NULL
);
/

-- * PRC guardar claves en ACS_CLAVE *
CREATE OR REPLACE PROCEDURE ACS_PRC_GUARDAR_CLAVE(
    P_NOMBRE_CLAVE IN ACS_CLAVE.ACL_NOMBRE_CLAVE%TYPE,
    P_TIPO IN ACS_CLAVE.ACL_TIPO%TYPE,
    P_CLAVE IN VARCHAR2
) AS
    V_CLAVE_ENCRIPTADA ACS_CLAVE.ACL_CLAVE%TYPE;
    V_KEY_RAW RAW(100);
    V_IV RAW(16);
    V_CIPH_RAW RAW(4000);
BEGIN
    -- Obtener la clave y convertirla a RAW
    V_KEY_RAW := UTL_RAW.CAST_TO_RAW('12345678901234567890123456789012'); -- 32 bytes (AES-256)

    -- Generar IV de 16 bytes
    V_IV := DBMS_CRYPTO.RANDOMBYTES(16);

    -- Encriptar con AES-256-CBC + PKCS5 y prefijar IV
    V_CIPH_RAW := DBMS_CRYPTO.ENCRYPT(
        SRC => UTL_RAW.CAST_TO_RAW(P_CLAVE),
        TYP => DBMS_CRYPTO.ENCRYPT_AES256 + DBMS_CRYPTO.CHAIN_CBC + DBMS_CRYPTO.PAD_PKCS5,
        KEY => V_KEY_RAW,
        IV  => V_IV
    );
    V_CLAVE_ENCRIPTADA := V_IV || V_CIPH_RAW;

    -- Actualizar o Insertar
    MERGE INTO ACS_CLAVE t
    USING (SELECT P_NOMBRE_CLAVE AS ACL_NOMBRE_CLAVE, P_TIPO AS ACL_TIPO FROM DUAL) s
    ON (t.ACL_NOMBRE_CLAVE = s.ACL_NOMBRE_CLAVE AND t.ACL_TIPO = s.ACL_TIPO)
    WHEN MATCHED THEN
        UPDATE SET t.ACL_CLAVE = V_CLAVE_ENCRIPTADA, t.ACL_TIPO = P_TIPO
    WHEN NOT MATCHED THEN
        INSERT (ACL_NOMBRE_CLAVE, ACL_TIPO, ACL_CLAVE)
        VALUES (P_NOMBRE_CLAVE, P_TIPO, V_CLAVE_ENCRIPTADA);

EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20001, 'Error al guardar la clave: ' || SQLERRM);
END ACS_PRC_GUARDAR_CLAVE;
/

-- * FUN obtener, desencriptar clave de ACS_CLAVE *
CREATE OR REPLACE FUNCTION ACS_FUN_OBTENER_CLAVE(
    P_NOMBRE_CLAVE IN ACS_CLAVE.ACL_NOMBRE_CLAVE%TYPE
) RETURN VARCHAR2 IS
    V_CLAVE_ENCRIPTADA ACS_CLAVE.ACL_CLAVE%TYPE;
    V_CLAVE_DESENCRIPTADA VARCHAR2(100);
    V_KEY_RAW RAW(100);
    V_IV RAW(16);
    V_CIPH_RAW RAW(4000);
BEGIN
    -- Obtener la clave y convertirla a RAW
    V_KEY_RAW := UTL_RAW.CAST_TO_RAW('12345678901234567890123456789012'); -- 32 bytes (AES-256)

    -- Recuperar la clave encriptada
    SELECT ACL_CLAVE INTO V_CLAVE_ENCRIPTADA
    FROM ACS_CLAVE
    WHERE ACL_NOMBRE_CLAVE = P_NOMBRE_CLAVE;

    -- Desencriptar la clave con formato nuevo (IV||CIPH). Si falla, probar compatibilidad.
    BEGIN
        IF LENGTH(V_CLAVE_ENCRIPTADA) > 16 THEN
            V_IV := UTL_RAW.SUBSTR(V_CLAVE_ENCRIPTADA, 1, 16);
            V_CIPH_RAW := UTL_RAW.SUBSTR(V_CLAVE_ENCRIPTADA, 17);
            V_CLAVE_DESENCRIPTADA := UTL_RAW.CAST_TO_VARCHAR2(
                DBMS_CRYPTO.DECRYPT(
                    SRC => V_CIPH_RAW,
                    TYP => DBMS_CRYPTO.ENCRYPT_AES256 + DBMS_CRYPTO.CHAIN_CBC + DBMS_CRYPTO.PAD_PKCS5,
                    KEY => V_KEY_RAW,
                    IV  => V_IV
                )
            );
        ELSE
            -- Intentar compatibilidad con legado DES sin IV
            V_CLAVE_DESENCRIPTADA := UTL_RAW.CAST_TO_VARCHAR2(
                DBMS_CRYPTO.DECRYPT(
                    SRC => V_CLAVE_ENCRIPTADA,
                    TYP => DBMS_CRYPTO.DES_CBC_PKCS5,
                    KEY => SUBSTR(V_KEY_RAW, 1, 8)
                )
            );
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            -- Intentar último recurso: AES-256-CBC con IV cero (posible valor previo inseguro)
            V_CLAVE_DESENCRIPTADA := UTL_RAW.CAST_TO_VARCHAR2(
                DBMS_CRYPTO.DECRYPT(
                    SRC => V_CLAVE_ENCRIPTADA,
                    TYP => DBMS_CRYPTO.ENCRYPT_AES256 + DBMS_CRYPTO.CHAIN_CBC + DBMS_CRYPTO.PAD_PKCS5,
                    KEY => V_KEY_RAW
                )
            );
    END;

    RETURN V_CLAVE_DESENCRIPTADA;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RETURN NULL;
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20002, 'Error al obtener la clave: ' || SQLERRM);
END ACS_FUN_OBTENER_CLAVE;
/
