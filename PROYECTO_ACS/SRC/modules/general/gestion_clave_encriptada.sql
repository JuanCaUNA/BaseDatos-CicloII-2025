-- !CLAVES
BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE ACS_CLAVE PURGE';
EXCEPTION
    WHEN OTHERS THEN
        IF SQLCODE != -942 THEN RAISE; END IF; -- IGNORAR SI NO EXISTE
END;
/

-- TABLA
CREATE TABLE ACS_CLAVE (
    ACL_ID       NUMBER GENERATED BY DEFAULT AS IDENTITY,
    ACL_NOMBRE_CLAVE VARCHAR2(50) UNIQUE NOT NULL,
    ACL_TIPO     VARCHAR2(20) NOT NULL, -- CORREO SMTP, OTRO
    ACL_CLAVE    RAW(400) NOT NULL
);
/

-- PRCEDIMIENTO
CREATE OR REPLACE PROCEDURE ACS_PRC_GUARDAR_CLAVE(
    P_NOMBRE_CLAVE IN ACS_CLAVE.ACL_NOMBRE_CLAVE%TYPE,
    P_TIPO IN ACS_CLAVE.ACL_TIPO%TYPE,
    P_CLAVE IN VARCHAR2
) AS
    V_CLAVE_ENCRIPTADA ACS_CLAVE.ACL_CLAVE%TYPE;
    V_KEY_RAW RAW(100);
    V_IV RAW(16);
    V_CIPH_RAW RAW(4000);
BEGIN
    -- OBTENER LA CLAVE Y CONVERTIRLA A RAW
    V_KEY_RAW := UTL_RAW.CAST_TO_RAW('12345678901234567890123456789012'); -- 32 BYTES (AES-256)

    -- GENERAR IV DE 16 BYTES PARA AES-CBC
    V_IV := DBMS_CRYPTO.RANDOMBYTES(16);

    -- ENCRIPTAR LA CLAVE CON AES-256-CBC + PKCS5 Y PREFIJAR EL IV AL CIPHERTEXT
    V_CIPH_RAW := DBMS_CRYPTO.ENCRYPT(
        SRC => UTL_RAW.CAST_TO_RAW(P_CLAVE),
        TYP => DBMS_CRYPTO.ENCRYPT_AES256 + DBMS_CRYPTO.CHAIN_CBC + DBMS_CRYPTO.PAD_PKCS5,
        KEY => V_KEY_RAW,
        IV  => V_IV
    );
    V_CLAVE_ENCRIPTADA := V_IV || V_CIPH_RAW; -- ALMACENAR IV || CIPHERTEXT

    -- ACTUALIZAR O INSERTAR
    MERGE INTO ACS_CLAVE T
    USING (SELECT P_NOMBRE_CLAVE AS ACL_NOMBRE_CLAVE, P_TIPO AS ACL_TIPO FROM DUAL) S
    ON (T.ACL_NOMBRE_CLAVE = S.ACL_NOMBRE_CLAVE AND T.ACL_TIPO = S.ACL_TIPO)
    WHEN MATCHED THEN
        UPDATE SET T.ACL_CLAVE = V_CLAVE_ENCRIPTADA
    WHEN NOT MATCHED THEN
        INSERT (ACL_NOMBRE_CLAVE, ACL_TIPO, ACL_CLAVE)
        VALUES (P_NOMBRE_CLAVE, P_TIPO, V_CLAVE_ENCRIPTADA);

EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20001, '[ERROR] (ACS_PRC_GUARDAR_CLAVE): ' || SQLERRM);
END ACS_PRC_GUARDAR_CLAVE;
/

-- FUNCION
CREATE OR REPLACE FUNCTION ACS_FUN_OBTENER_CLAVE(
    P_NOMBRE_CLAVE IN ACS_CLAVE.ACL_NOMBRE_CLAVE%TYPE
) RETURN VARCHAR2 IS
    V_CLAVE_ENCRIPTADA ACS_CLAVE.ACL_CLAVE%TYPE;
    V_CLAVE_DESENCRIPTADA VARCHAR2(100);
    V_KEY_RAW RAW(100);
    V_DECRYPTED_RAW RAW(4000);
    V_IV RAW(16); -- ES EL IV (VECTOR DE INICIALIZACIÓN)
    V_CIPH_RAW RAW(4000); -- ES EL CIPHERTEXT (TEXTO CIFRADO)
BEGIN
    -- OBTENER LA CLAVE Y CONVERTIRLA A RAW
    V_KEY_RAW := UTL_RAW.CAST_TO_RAW('12345678901234567890123456789012'); -- 32 BYTES (AES-256)

    -- RECUPERAR LA CLAVE ENCRIPTADA
    SELECT ACL_CLAVE INTO V_CLAVE_ENCRIPTADA
    FROM ACS_CLAVE
    WHERE ACL_NOMBRE_CLAVE = P_NOMBRE_CLAVE;

    -- DESENCRIPTAR LA CLAVE
    -- REGLA: SI EL TAMAÑO ES > 16 BYTES, ASUMIMOS FORMATO NUEVO (IV||CIPH) CON AES-256-CBC.
    -- EN CASO CONTRARIO, INTENTAMOS COMPATIBILIDAD CON EL FORMATO LEGADO DES-CBC-PKCS5 SIN IV.
    IF LENGTH(V_CLAVE_ENCRIPTADA) > 16 THEN
        -- EXTRAER IV (PRIMEROS 16 BYTES) Y CIPHERTEXT (RESTO)
        V_IV := UTL_RAW.SUBSTR(V_CLAVE_ENCRIPTADA, 1, 16);
        V_CIPH_RAW := UTL_RAW.SUBSTR(V_CLAVE_ENCRIPTADA, 17);
        V_DECRYPTED_RAW := DBMS_CRYPTO.DECRYPT(
            SRC => V_CIPH_RAW,
            TYP => DBMS_CRYPTO.ENCRYPT_AES256 + DBMS_CRYPTO.CHAIN_CBC + DBMS_CRYPTO.PAD_PKCS5,
            KEY => V_KEY_RAW,
            IV  => V_IV
        );
    ELSE
        -- COMPATIBILIDAD HACIA ATRÁS (VALORES ANTIGUOS DES_CBC_PKCS5 SIN IV)
        V_DECRYPTED_RAW := DBMS_CRYPTO.DECRYPT(
            SRC => V_CLAVE_ENCRIPTADA,
            TYP => DBMS_CRYPTO.DES_CBC_PKCS5,
            KEY => SUBSTR(V_KEY_RAW, 1, 8) -- DES NECESITA 8 BYTES
        );
    END IF;
    
    -- CONVERTIR RAW A VARCHAR2
    V_CLAVE_DESENCRIPTADA := UTL_RAW.CAST_TO_VARCHAR2(V_DECRYPTED_RAW);

    RETURN V_CLAVE_DESENCRIPTADA;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('[ERROR] (ACS_FUN_OBTENER_CLAVE): No existe la clave: ' || P_NOMBRE_CLAVE);
        RAISE_APPLICATION_ERROR(-20004, '[ERROR] (ACS_FUN_OBTENER_CLAVE): No existe la clave: ' || P_NOMBRE_CLAVE);
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('[ERROR] (ACS_FUN_OBTENER_CLAVE): ' || SQLERRM);
        RAISE_APPLICATION_ERROR(-20002, '[ERROR] (ACS_FUN_OBTENER_CLAVE): ' || SQLERRM);
END ACS_FUN_OBTENER_CLAVE;
/